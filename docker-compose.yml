services:
  # API + Scheduler (Express)
  backend:
    restart: unless-stopped
    build:
      context: .
      dockerfile: docker/Dockerfile.backend
    env_file: .env
    environment:
      NODE_ENV: ${NODE_ENV:-production}
      BACKEND_INTERNAL_PORT: ${BACKEND_INTERNAL_PORT:-3000}
      APP_PORT: ${BACKEND_INTERNAL_PORT:-3000}
    # Optional: Backend-API extern freigeben (z. B. für separate Clients)
    # ports:
    #   - "${BACKEND_PORT:-3000}:${BACKEND_INTERNAL_PORT:-3000}"
    volumes:
      - data:/app/data
    healthcheck:
      test: ["CMD-SHELL", "node -e \"const p=process.env.BACKEND_INTERNAL_PORT||process.env.APP_PORT||3000; fetch('http://localhost:'+p+'/health').then(r=>process.exit(r.ok?0:1)).catch(()=>process.exit(1));\" "]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 20s
#    depends_on:
#      - db

  # Statisches React-Dashboard, ausgeliefert über Nginx + API-Proxy
  frontend:
    restart: unless-stopped
    build:
      # Setze den Build‑Kontext per ENV, damit auch externe Ordnerstrukturen funktionieren.
      # Erwarte hier den Projekt‑Root, der sowohl "dashboard/" als auch "bsky-client/" enthält.
      # Beispiel Aufruf:
      #   FRONTEND_BUILD_CONTEXT=/pfad/zum/projekt docker compose build frontend
      context: ${FRONTEND_BUILD_CONTEXT:-.}
      dockerfile: docker/Dockerfile.frontend
    ports:
      - "${FRONTEND_PORT:-8080}:80"
    environment:
      BACKEND_SERVICE_HOST: ${BACKEND_SERVICE_HOST:-backend}
      BACKEND_SERVICE_PORT: ${BACKEND_INTERNAL_PORT:-3000}
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost/ >/dev/null || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 10
      start_period: 30s

volumes:
  data:

#  db:
#    image: postgres:15
#    environment:
#      POSTGRES_USER: bsky
#      POSTGRES_PASSWORD: bsky_pass
#      POSTGRES_DB: bsky_campaigns
#    volumes:
#      - db_data:/var/lib/postgresql/data

#volumes:
#  db_data:
