// src/services/postService.js
/**
 * Abstraktionsebene, die Inhalte an Plattformprofile delegiert.
 *
 * Dadurch bleibt der Rest des Codes unabhängig von konkreten APIs; jedes
 * Profil definiert, wie validiert, normalisiert und gepostet wird.
 */
const { getProfile } = require("../platforms/registry");

/**
 * @typedef {{ content: string, scheduledAt?: string | Date }} PostInput
 * @typedef {{ [k: string]: any }} PlatformEnv
 */

/**
 * Einfache Retry/Backoff-Strategie mit Exponential-Backoff + Jitter.
 * Über ENV konfigurierbar: POST_RETRIES, POST_BACKOFF_MS (Basis), POST_BACKOFF_MAX_MS.
 */
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function isRetryable(error) {
  const msg = (error?.message || "").toLowerCase();
  const status = error?.status || error?.statusCode;

  if (typeof status === "number") {
    if (status === 429) return TrueLike.TRUE;       // Rate Limit
    if (status >= 500) return TrueLike.TRUE;        // Serverfehler
    if (status >= 400 && status < 500) return FalseLike.FALSE; // Clientfehler: nicht retrybar
  }

  // Netzwerk-/Transport-Fehler heuristisch
  const retryHints = ["etimedout", "econnreset", "enotfound", "network", "temporarily", "timeout", "rate limit"];
  if (retryHints.some((k) => msg.includes(k))) {
    return TrueLike.TRUE;
  }

  return FalseLike.FALSE;
}

// Kleine „enum“-Helfer für Lesbarkeit im return
const TrueLike = { TRUE: true };
const FalseLike = { FALSE: false };

async function withRetry(fn, opts = {}) {
  const maxRetries = Number(process.env.POST_RETRIES || opts.retries || 3);
  const baseMs = Number(process.env.POST_BACKOFF_MS || opts.baseMs || 500);
  const maxMs = Number(process.env.POST_BACKOFF_MAX_MS || opts.maxMs || 4000);

  let attempt = 0;
  while (true) {
    try {
      return await fn();
    } catch (err) {
      attempt += 1;
      const retryable = isRetryable(err);

      if (!retryable || attempt > maxRetries) {
        // Letzter Versuch oder nicht retrybar -> Fehler weiterreichen
        err.attempts = attempt;
        throw err;
      }

      // Exponential Backoff mit Jitter
      const delay = Math.min(maxMs, baseMs * Math.pow(2, attempt - 1));
      const jitter = Math.floor(Math.random() * Math.floor(delay * 0.25));
      const wait = delay + jitter;

      console.warn(
        `⚠️  Post fehlgeschlagen (Versuch ${attempt}/${maxRetries}). Warten ${wait}ms und erneut versuchen…`,
        err?.message || err
      );
      await sleep(wait);
    }
  }
}

/**
 * Sendet einen Post an die angegebene Plattform.
 * Wirft bei ungültigem Input oder irreparablem Fehler (nach Retries).
 *
 * @param {"bluesky"|"mastodon"} platformId
 * @param {PostInput} input
 * @param {PlatformEnv} env
 */
async function sendPost(platformId, input, env) {
  if (!platformId) {
    throw new Error("platformId ist erforderlich.");
  }

  const profile = getProfile(platformId);
  if (!profile) {
    throw new Error(`Unbekannte Plattform: ${platformId}`);
  }

  const check = profile.validate(input);
  if (!check.ok) {
    throw new Error(check.errors?.join("; ") || "Ungültiger Inhalt.");
  }

  // Profil entscheidet über Normalisierung & Payload
  const payload = profile.toPostPayload(input);

  // Retry um den eigentlichen Post-Aufruf
  return await withRetry(() => profile.post(payload, env));
}

module.exports = {
  sendPost,
};
